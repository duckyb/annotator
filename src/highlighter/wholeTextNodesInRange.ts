import { isNodeInRange } from '../range-util';

/**
 * Return text nodes which are entirely inside `range`.
 *
 * If a range starts or ends part-way through a text node, the node is split
 * and the part inside the range is returned.
 *
 * @param {Range} range
 * @return {Text[]}
 */
export function wholeTextNodesInRange(range: Range): Text[] {
  if (range.collapsed) {
    // Exit early for an empty range to avoid an edge case that breaks the algorithm
    // below. Splitting a text node at the start of an empty range can leave the
    // range ending in the left part rather than the right part.
    return [];
  }

  /** @type {Node|null} */
  let root = range.commonAncestorContainer;
  if (root.nodeType !== Node.ELEMENT_NODE) {
    // If the common ancestor is not an element, set it to the parent element to
    // ensure that the loop below visits any text nodes generated by splitting
    // the common ancestor.
    //
    // Note that `parentElement` may be `null`.
    root = root.parentElement as Node;
  }
  if (!root) {
    // If there is no root element then we won't be able to insert highlights,
    // so exit here.
    return [];
  }

  const textNodes: Text[] = [];
  const nodeIter = root.ownerDocument?.createNodeIterator(
    root,
    NodeFilter.SHOW_TEXT // Only return `Text` nodes.
  );
  let node: Node | null | undefined;
  while ((node = nodeIter?.nextNode())) {
    if (!isNodeInRange(range, node as HTMLElement)) {
      continue;
    }
    const text = /** @type {Text} */ node;

    if (text === range.startContainer && range.startOffset > 0) {
      // Split `text` where the range starts. The split will create a new `Text`
      // node which will be in the range and will be visited in the next loop iteration.
      (text as Text).splitText(range.startOffset);
      continue;
    }

    if (
      text === range.endContainer &&
      range.endOffset < (text as Text).data.length
    ) {
      // Split `text` where the range ends, leaving it as the part in the range.
      (text as Text).splitText(range.endOffset);
    }

    textNodes.push(text as Text);
  }

  return textNodes;
}
